# -*- coding: utf-8 -*-
"""Ubah_RC_Mandiri_Jadi_Excel_Mutasi_Rekening.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H9jeQq6X0DaxLtutom7cKGlXUld8hz8g

# Convert Rekening Koran Mandiri dari PDF jadi Excel

# Cara Penggunaan
[Video Demo](https://www.youtube.com/shorts/n8uJNjP8Gog)
1. Klik ikon **Files** (gambar folder) di sebelah kiri untuk menampilkan daftar file dan folder
2. Klik ikon **upload** (gambar kertas dengan panah ke atas)
3. Pilih file PDF Rekening koran Mandiri, boleh lebih dari 1 file. Jika muncul **Warning**, klik **OK**
4. Isi password pada bagian **Password**, contohnya jika terdapat 2 file dengan 2 password berbeda, bagian tersebut menjadi
`pass = ['password1', 'password2']`
5. Klik menu **Runtime > Run All** di bagian atas. Jika muncul **Warning**, klik **Run anyway**
6. Tunggu beberapa saat
7. Klik ikon **refresh** (gambar panah bulat di sebelah ikon upload)
8. Pilih file **Mandiri_Excel.xlsx**, klik ikon **tiga titik** di kanan file tersebut
9. Pilih **Download**

## Password
"""

passwd = ['password']

"""## Jarak Antar Data"""

lag_between_data = 15
remarks_left = 100
remarks_right = 300

"""## Format Rekening Koran yang Didukung: April 2025"""

!pip install pdfplumber pikepdf

#!apt-get install ghostscript -y

import math, json, requests, time, os, glob, shutil, pdfplumber, warnings, re#, tabula
#import ocrmypdf
import pikepdf
import pandas as pd

from tqdm.notebook import tqdm
from datetime import datetime
from pikepdf import Pdf

warnings.filterwarnings("ignore")

def is_pdf_password_protected(pdf_path):
  """
  Checks if a PDF file is password protected.

  Args:
    pdf_path: The path to the PDF file.

  Returns:
    True if the PDF is password protected, False otherwise.
  """
  try:
    Pdf.open(pdf_path)
    return False  # If opening without password succeeds, it's not protected
  except pikepdf.PasswordError:
    return True  # If PasswordError is raised, it's protected
  except Exception as e:
    print(f"An error occurred while checking PDF: {e}")
    return False  # Assume not protected for other errors

def unlock_and_save_pdf(pdf_path, password, output_path):
  """
  Unlocks a password-protected PDF and saves it to a new path.

  Args:
    pdf_path: The path to the password-protected PDF file.
    password: The password to unlock the PDF.
    output_path: The path to save the unlocked PDF file.
  """
  try:
    pdf = Pdf.open(pdf_path, password=password, allow_overwriting_input=True)
    pdf.save(output_path)
    print(f"Successfully unlocked and saved PDF to: {output_path}")
  except Exception as e:
    print(f"Error unlocking or saving PDF: {e}")

# Example usage (you'll need to replace with your actual file path and password)
# password = "your_password"
# pdf_file_path = "your_protected_pdf.pdf"
# unlocked_pdf_path = "unlocked_" + os.path.basename(pdf_file_path)
# unlock_and_save_pdf(pdf_file_path, password, unlocked_pdf_path)

def has_two_monetary_amounts(text):
    """
    Detects if a text contains at least two monetary amounts in the format 0,000.00.

    Args:
        text: The input text string.

    Returns:
        True if at least two monetary amounts are found, False otherwise.
    """
    pattern = r"\d{1,3}(?:\.\d{3})*,\d{2}"  # Matches monetary amounts like -0.000,00
    matches = re.findall(pattern, text)
    return len(matches) >= 2

def has_three_monetary_amounts(text):
    """
    Detects if a text contains at least two monetary amounts in the format 0,000.00.

    Args:
        text: The input text string.

    Returns:
        True if at least two monetary amounts are found, False otherwise.
    """
    pattern = r"\d{1,3}(?:,\d{3})*\.\d{2}"  # Matches monetary amounts like -0.000,00
    matches = re.findall(pattern, text)
    return len(matches) >= 3

def has_time(text):
    """
    Checks if a text contains time in the format hh:mm:ss.

    Args:
        text: The input text string.

    Returns:
        True if time in the format hh:mm:ss is found, False otherwise.
    """
    pattern = r"\d{2}:\d{2}:\d{2}"
    match = re.search(pattern, text)
    return bool(match)

def has_one_monetary_amount(text):
    """
    Detects if a text contains exactly one monetary amount in the format 0,000.00.

    Args:
        text: The input text string.

    Returns:
        True if exactly one monetary amount is found, False otherwise.
    """
    pattern = r"\d{1,3}(?:\.\d{3})*,\d{2}"  # Matches monetary amounts like 0.000,00
    matches = re.findall(pattern, text)
    return len(matches) == 1

def has_two_monetary_amounts_with_db(text):
    """
    Detects if a text contains two monetary amounts separated by "DB".

    Args:
        text: The input text string.

    Returns:
        True if two monetary amounts separated by "DB" are found, False otherwise.
    """
    pattern = r"(\d{1,3}(?:,\d{3})*\.\d{2})\s*DB\s*(\d{1,3}(?:,\d{3})*\.\d{2})"
    match = re.search(pattern, text)
    return bool(match)

def does_not_contain_monetary_amount(text):
    """
    Detects if a text does not contain any monetary amounts in the format 0,000.00.

    Args:
        text: The input text string.

    Returns:
        True if no monetary amounts are found, False otherwise.
    """
    pattern = r"\d{1,3}(?:\.\d{3})*,\d{2}"  # Matches monetary amounts like 0.000,00
    matches = re.findall(pattern, text)
    return len(matches) == 0

def has_monetary_amount_followed_by_db(text):
    """
    Detects if a text contains a monetary amount followed by "DB".

    Args:
        text: The input text string.

    Returns:
        True if a monetary amount followed by "DB" is found, False otherwise.
    """
    # Find all monetary amounts
    monetary_amounts = re.findall(r"\d{1,3}(?:\.\d{3})*,\d{2}", text)

    if not monetary_amounts:
      return False

    first_monetary_amount = monetary_amounts[0]

    # Check if "DB" appears after the first monetary amount
    pattern = rf"{first_monetary_amount}\s*DB"  # Using f-string for dynamic pattern
    match = re.search(pattern, text)

    return bool(match)

def get_first_monetary_amount(text):
    """
    Extracts the first monetary amount in the format 0,000.00 from a text string.

    Args:
        text: The input text string.

    Returns:
        The first monetary amount found as a string, or None if no match is found.
    """
    match = re.search(r"[+-]?\d{1,3}(?:\.\d{3})*,\d{2}", text)
    if match:
        return match.group(0)
    else:
        return None

def get_last_monetary_amount(text):
    """
    Extracts the last monetary amount in the format 0,000.00 from a text string.

    Args:
        text: The input text string.

    Returns:
        The last monetary amount found as a string, or None if no match is found.
    """
    matches = re.findall(r"\d{1,3}(?:\.\d{3})*,\d{2}", text)
    if matches:
        return matches[-1]  # Return the last match
    else:
        return None

def get_text_before_first_monetary_amount(text):
  """
  If a text contains at least two monetary amounts, keeps the text before the first monetary amount.
  Otherwise, returns the original text.

  Args:
    text: The input text string.

  Returns:
    The text before the first monetary amount if two or more are found,
    otherwise the original text.
  """
  if has_two_monetary_amounts(text):
    match = re.search(r"\d{1,3}(?:\.\d{3})*,\d{2}", text)
    if match:
      return text[:match.start()].strip()
  return text

def convert_text_to_float(text):
    return float(text.replace('\.', ''))

def remove_sequence(text):
  """
  If a string begins with digits, remove the digits and keep the rest of the text.

  Args:
    text: The input string.

  Returns:
    The string with leading digits removed, or the original string if it doesn't
    start with digits.
  """
  if text:
    if len(text.split()) < 2:
      return text
    else:
    #and text[0].isdigit():
        # Find the index of the first non-digit character
        match = re.search(r'^\d+', text)
        if match:
            end_index = match.end()
            return text[end_index:]
  return text

def remove_excessive_space(text):
    return re.sub(r'\s+', ' ', text).strip()

def extract_type1(pdf = None):
    ls = []
    awal_data = False
    awal_trx_desc = False

    for page in pdf.pages:
        trx_date = None
        trx_desc = ''
        trx_code = 'K'
        trx_amount = None
        trx_balance = None

        words = page.extract_words()
        prev_top = 0
        remarks_top = 1000
        ojk_bottom = 10000

        first_desc = ''

        for word in words:
            #print(remarks_top)
            print(word)
            if '(persero)' in word['text'].lower():
                ojk_bottom = word['top']

            if 'ini adalah batas akhir' in first_desc.lower():
                ojk_bottom = word['top']

            top = word['top']
            top_lag = top - prev_top

            if top > remarks_top:# and top < ojk_bottom:

                if top_lag > lag_between_data:
                    if first_desc:
                        print(first_desc)
                        if has_time(first_desc):
                            # Extract description from same line (after removing time)
                            time_text = first_desc.split('WIB')[0].strip()
                            trx_date_formatted += f" {time_text}"
                            trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                    if trx_date is not None and trx_desc is not None: #and trx_amount is not None:
                        trx_desc = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', trx_desc).strip()
                        trx_desc = remove_sequence(trx_desc)
                        trx_desc = remove_excessive_space(trx_desc)

                        #print('date:', trx_date, 'desc:', trx_desc, 'code:', trx_code, 'amount:', trx_amount, 'balance:', trx_balance)
                        ls.append({
                            'tanggal': trx_date,
                            'keterangan': trx_desc,
                            'kode': trx_code,
                            'mutasi': trx_amount,
                            'saldo': trx_balance,
                            'saldo_teks': trx_balance,
                            'no_rekening': account_num
                        })

                        # Reset for new transaction's data
                        trx_date = None
                        trx_desc = ''
                        trx_code = 'K'
                        trx_amount = None
                        trx_balance = None

                    first_desc = word['text']

                if top_lag > 0 and top_lag <= lag_between_data:
                    date_match = re.search(r'(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|Mei|Agu|Okt|Des)\s+(\d{4})', first_desc)

                    if date_match:
                        day = date_match.group(1)
                        month_name = date_match.group(2)
                        year = date_match.group(3)

                        month_map = {
                            'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                            'May': '05', 'Mei': '05', 'Jun': '06', 'Jul': '07',
                            'Aug': '08', 'Agu': '08', 'Sep': '09', 'Oct': '10',
                            'Nov': '11', 'Dec': '12'
                        }
                        month = month_map.get(month_name, '01')
                        trx_date_formatted = f"{day.zfill(2)}/{month}/{year}"
                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y').date()

                    elif has_time(first_desc):
                        # Extract description from same line (after removing time)
                        time_text = first_desc.split('WIB')[0].strip()
                        trx_date_formatted += f" {time_text}"
                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                    elif has_two_monetary_amounts(first_desc):
                        amounts = re.findall(r'[+-]?\d{1,3}(?:\.\d{3})*,\d{2}', first_desc)
                        if len(amounts) >= 2:
                            trx_amount = amounts[0].replace('-', '') if amounts[0].startswith('-') else amounts[0].replace('+', '')
                            trx_balance = amounts[1]

                            if amounts[0].startswith('-'):
                                trx_code = 'D'
                            else:
                                trx_code = 'K'

                    first_desc = word['text']

                if top_lag <= 0:
                    first_desc = first_desc + ' ' + word['text']

                if word['x0'] > remarks_left and word['x0'] < remarks_right:
                    trx_desc = trx_desc + ' ' + word['text']

            if 'remark' in word['text'].lower():
                remarks_top = word['top']

        if first_desc:
            print(first_desc)
            if has_time(first_desc):
                # Extract description from same line (after removing time)
                time_text = first_desc.split('WIB')[0].strip()
                trx_date_formatted += f" {time_text}"
                trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

            if trx_date is not None and trx_desc is not None: #and trx_amount is not None:
                trx_desc = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', trx_desc).strip()
                trx_desc = remove_sequence(trx_desc)
                trx_desc = remove_excessive_space(trx_desc)

                #print('date:', trx_date, 'desc:', trx_desc, 'code:', trx_code, 'amount:', trx_amount, 'balance:', trx_balance)
                ls.append({
                    'tanggal': trx_date,
                    'keterangan': trx_desc,
                    'kode': trx_code,
                    'mutasi': trx_amount,
                    'saldo': trx_balance,
                    'saldo_teks': trx_balance,
                    'no_rekening': account_num
                })

                        # Reset for new transaction's data
                trx_date = None
                trx_desc = ''
                trx_code = 'K'
                trx_amount = None
                trx_balance = None

    return ls

def extract_type2(pdf = None):
    ls = []
    awal_data = False
    awal_trx_desc = False

    for page in pdf.pages:
        trx_date = None
        trx_desc = ''
        trx_code = 'K'
        trx_amount = None
        trx_balance = None

        words = page.extract_words()
        prev_top = 0
        remarks_top = 1000
        ojk_bottom = 10000

        first_desc = ''

        for word in words:
            #print(remarks_top)
            #print(word)
            #if '(persero)' in word['text'].lower():
            #    ojk_bottom = word['top']

            #if 'ini adalah batas akhir' in first_desc.lower():
            #    ojk_bottom = word['top']

            top = word['top']
            top_lag = top - prev_top

            if top > remarks_top:# and top < ojk_bottom:
                #print(word)
                if top_lag > lag_between_data: # text in the different data
                    #print('1.', word)
                    if first_desc:
                        if has_time(first_desc):
                            # Extract description from same line (after removing time)
                            time_text = first_desc.split()[0].strip()
                            trx_date_formatted += f" {time_text}"
                            trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                    if trx_date is not None and trx_desc is not None: #and trx_amount is not None:
                        trx_desc = re.sub(r'\d{2}:\d{2}:\d{2}\s+', '', trx_desc).strip()
                        trx_desc = remove_sequence(trx_desc)
                        trx_desc = remove_excessive_space(trx_desc)

                        #print('date:', trx_date, 'desc:', trx_desc, 'code:', trx_code, 'amount:', trx_amount, 'balance:', trx_balance)
                        ls.append({
                            'tanggal': trx_date,
                            'keterangan': trx_desc,
                            'kode': trx_code,
                            'mutasi': trx_amount,
                            'saldo': trx_balance,
                            'saldo_teks': trx_balance,
                            'no_rekening': account_num
                        })

                        # Reset for new transaction's data
                        trx_date = None
                        trx_desc = ''
                        trx_code = 'K'
                        trx_amount = None
                        trx_balance = None

                    first_desc = word['text']

                if top_lag > 0 and top_lag <= lag_between_data: # text in the same data
                    #print('2.', word)
                    #print(first_desc)

                    date_match = re.search(r'(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|Mei|Agu|Okt|Des)\s+(\d{4})', first_desc)

                    if date_match:
                        day = date_match.group(1)
                        month_name = date_match.group(2)
                        year = date_match.group(3)

                        month_map = {
                            'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                            'May': '05', 'Mei': '05', 'Jun': '06', 'Jul': '07',
                            'Aug': '08', 'Agu': '08', 'Sep': '09', 'Oct': '10',
                            'Nov': '11', 'Dec': '12'
                        }
                        month = month_map.get(month_name, '01')
                        trx_date_formatted = f"{day.zfill(2)}/{month}/{year}"
                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y').date()
                        #print(trx_date)

                    elif has_time(first_desc):
                        # Extract description from same line (after removing time)
                        time_text = first_desc.split()[0].strip()
                        trx_date_formatted += f" {time_text}"
                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                    elif has_three_monetary_amounts(first_desc):
                        amounts = re.findall(r'[+-]?\d{1,3}(?:,\d{3})*\.\d{2}', first_desc)
                        if len(amounts) >= 3:
                            #trx_amount = amounts[0].replace('-', '') if amounts[0].startswith('-') else amounts[0].replace('+', '')
                            trx_db = amounts[0].replace(',', '')
                            trx_cr = amounts[1].replace(',', '')
                            trx_balance = amounts[-1].replace(',', '')

                            if float(trx_db) > 0: trx_code = 'D'
                            else: trx_code = 'K'

                            trx_amount = float(trx_db) + float(trx_cr)
                            trx_amount = str(trx_amount).replace('.', ',')
                            trx_balance = str(trx_balance).replace('.', ',')
                            #if amounts[0].startswith('-'):
                                #trx_code = 'D'
                            #else:
                                #trx_code = 'K'

                    first_desc = word['text']

                if top_lag <= 0: # text in the same line
                    #print('3.', word)
                    first_desc = first_desc + ' ' + word['text']

                if word['x0'] > remarks_left and word['x0'] < remarks_right:
                    trx_desc = trx_desc + ' ' + word['text']


            if 'remark' in word['text'].lower():
                remarks_top = word['top']

            prev_top = top

        if first_desc:
            if has_time(first_desc):
                # Extract description from same line (after removing time)
                time_text = first_desc.split()[0].strip()
                trx_date_formatted += f" {time_text}"
                trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

            if trx_date is not None and trx_desc is not None: #and trx_amount is not None:
                trx_desc = re.sub(r'\d{2}:\d{2}:\d{2}\s+', '', trx_desc).strip()
                trx_desc = remove_sequence(trx_desc)
                trx_desc = remove_excessive_space(trx_desc)

                #print('date:', trx_date, 'desc:', trx_desc, 'code:', trx_code, 'amount:', trx_amount, 'balance:', trx_balance)
                ls.append({
                    'tanggal': trx_date,
                    'keterangan': trx_desc,
                    'kode': trx_code,
                    'mutasi': trx_amount,
                    'saldo': trx_balance,
                    'saldo_teks': trx_balance,
                    'no_rekening': account_num
                })

                        # Reset for new transaction's data
                trx_date = None
                trx_desc = ''
                trx_code = 'K'
                trx_amount = None
                trx_balance = None

    return ls

pdf_list = glob.glob("*.pdf")

if pdf_list:
  ls_df = []

  for pdf_file in tqdm(pdf_list, desc="Processing PDFs"):
        try:
            account_num = ''
            ls = []

            is_protected = is_pdf_password_protected(pdf_file)

            if is_protected:
                for p in passwd:
                    unlock_and_save_pdf(pdf_file, p, pdf_file)

            with pdfplumber.open(pdf_file) as pdf:
                is_type_2 = False #
                is_account_num_detected = False

                # Get Account Number
                for page in pdf.pages:
                    text = page.extract_text()
                    lines = text.split('\n')
                    for line in lines:
                        if 'nomor rekening' in line.lower() and ':' in line:
                            account_num = line.split(':')[1].strip().split()[0]

                        if line.strip().lower() == 'account statement':
                            is_type_2 = True

                        # Grab account number for type 2 PDF
                        if is_account_num_detected:
                            account_num = line.strip().split()[0]
                            is_account_num_detected = False

                        if 'account name' in line.lower():
                            is_account_num_detected = True

                # Get Transactions
                awal_data = False
                awal_trx_desc = False

                if is_type_2:
                    ls = extract_type2(pdf)
                else:
                    for page in pdf.pages:
                        trx_date = None
                        trx_desc = ''
                        trx_code = 'K'
                        trx_amount = None
                        trx_balance = None

                        words = page.extract_words()
                        prev_top = 0
                        remarks_top = 1000
                        ojk_bottom = 10000

                        first_desc = ''
                        for word in words:
                            if '(persero)' in word['text'].lower():
                                ojk_bottom = word['top']

                            if 'ini adalah batas akhir' in first_desc.lower():
                                ojk_bottom = word['top']

                            top = word['top']
                            top_lag = top - prev_top

                            if top > remarks_top and top < ojk_bottom:
                                #print(word)
                                if top_lag > lag_between_data:
                                    if first_desc:
                                        #print('--------------------------------------')
                                        #print(first_desc)
                                        #trx_desc = first_desc

                                        if has_time(first_desc):
                                            # Extract description from same line (after removing time)
                                            time_text = first_desc.split('WIB')[0].strip()
                                            trx_date_formatted += f" {time_text}"
                                            trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                                            #remaining_text = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', trx_desc).strip()
                                            #if remaining_text and not re.match(r'^\d+$', remaining_text):
                                                #if trx_desc == "" or trx_desc is None:
                                                    #trx_desc = remaining_text
                                                #else:
                                                    #trx_desc += " " + remaining_text

                                        #else:
                                            #trx_desc = first_desc

                                    if trx_date is not None and trx_desc is not None: #and trx_amount is not None:
                                        #print('++++++++++++++++++++++++++++++++++++++++++++++++++')
                                        #print('++++++++++++++++++++++++++++++++++++++++++++++++++')

                                        trx_desc = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', trx_desc).strip()
                                        trx_desc = remove_sequence(trx_desc)
                                        trx_desc = remove_excessive_space(trx_desc)

                                        #print('date:', trx_date, 'desc:', trx_desc, 'code:', trx_code, 'amount:', trx_amount, 'balance:', trx_balance)
                                        ls.append({
                                            'tanggal': trx_date,
                                            'keterangan': trx_desc,
                                            'kode': trx_code,
                                            'mutasi': trx_amount,
                                            'saldo': trx_balance,
                                            'saldo_teks': trx_balance,
                                            'no_rekening': account_num
                                        })

                                        # Reset for new transaction's data
                                        trx_date = None
                                        trx_desc = ''
                                        trx_code = 'K'
                                        trx_amount = None
                                        trx_balance = None

                                    first_desc = word['text']
                                    #trx_desc = first_desc.strip()
                                    #print(trx_desc)

                                if top_lag > 0 and top_lag <= lag_between_data:
                                    #print('--------------------------------------')
                                    #print(first_desc)
                                    #trx_desc = trx_desc + ' ' + first_desc

                                    date_match = re.search(r'(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|Mei|Agu|Okt|Des)\s+(\d{4})', first_desc)

                                    if date_match:
                                        day = date_match.group(1)
                                        month_name = date_match.group(2)
                                        year = date_match.group(3)

                                        month_map = {
                                            'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
                                            'May': '05', 'Mei': '05', 'Jun': '06', 'Jul': '07',
                                            'Aug': '08', 'Agu': '08', 'Sep': '09', 'Oct': '10',
                                            'Nov': '11', 'Dec': '12'
                                        }
                                        month = month_map.get(month_name, '01')
                                        trx_date_formatted = f"{day.zfill(2)}/{month}/{year}"
                                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y').date()

                                        # Extract description from same line (after removing date and time)
                                        #remaining_text = re.sub(r'\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|Mei|Agu|Okt|Des)\s+\d{4}', '', first_desc).strip()
                                        #remaining_text = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', remaining_text).strip()
                                        #if remaining_text and not re.match(r'^\d+$', remaining_text):
                                        #    if trx_desc == "" or trx_desc is None:
                                        #        trx_desc = remaining_text
                                        #    else:
                                        #        trx_desc += " " + remaining_text

                                    elif has_time(first_desc):
                                        # Extract description from same line (after removing time)
                                        time_text = first_desc.split('WIB')[0].strip()
                                        trx_date_formatted += f" {time_text}"
                                        trx_date = datetime.strptime(trx_date_formatted, '%d/%m/%Y %H:%M:%S')

                                        #remaining_text = re.sub(r'\d{2}:\d{2}:\d{2}\s+WIB', '', first_desc).strip()
                                        #if remaining_text and not re.match(r'^\d+$', remaining_text):
                                        #    if trx_desc == "" or trx_desc is None:
                                        #        trx_desc = remaining_text
                                        #    else:
                                        #        trx_desc += " " + remaining_text

                                    elif has_two_monetary_amounts(first_desc):
                                        amounts = re.findall(r'[+-]?\d{1,3}(?:\.\d{3})*,\d{2}', first_desc)
                                        if len(amounts) >= 2:
                                            trx_amount = amounts[0].replace('-', '') if amounts[0].startswith('-') else amounts[0].replace('+', '')
                                            trx_balance = amounts[1]

                                            if amounts[0].startswith('-'):
                                                trx_code = 'D'
                                            else:
                                                trx_code = 'K'

                                            #remaining_text = get_text_before_first_monetary_amount(line)
                                            #if remaining_text:
                                            #    if trx_desc == "" or trx_desc is None:
                                            #        trx_desc = remove_sequence(remaining_text)
                                            #    else:
                                            #        trx_desc += " " + remove_sequence(remaining_text)

                                    '''else:
                                        if trx_desc == "" or trx_desc is None:
                                            trx_desc = remove_sequence(first_desc.strip())
                                        else:
                                            trx_desc += " " + remove_sequence(first_desc.strip())'''

                                    first_desc = word['text']
                                    #first_desc = first_desc + ' ' + word['text']
                                    #print(word)

                                if top_lag <= 0:
                                    first_desc = first_desc + ' ' + word['text']

                                if word['x0'] > remarks_left and word['x0'] < remarks_right:
                                    trx_desc = trx_desc + ' ' + word['text']

                            if 'remarks' in word['text'].lower():
                                remarks_top = word['top']

                            prev_top = top

            df = pd.DataFrame(ls)
            df = df.sort_values(by=['tanggal'], ascending=[True]).reset_index(drop=True)
            df['mutasi'] = df['mutasi'].astype(str).str.replace('\.', '', regex=True).str.replace(',', '.', regex=False).astype(float)
            df['saldo'] = df['saldo'].astype(str).str.replace('\.', '', regex=True).str.replace(',', '.', regex=False).astype(float)
            df['saldo_teks'] = df['saldo_teks'].astype(str).str.replace('\.', '', regex=True).str.replace(',', '.', regex=False).astype(float)
            df['sequence'] = range(1, len(df) + 1)

            # Iterate through the DataFrame to calculate trx_balance_recalculate
            '''for i in range(len(df)):
                if i == 0:
                    df.loc[i, 'saldo'] = df.loc[i, 'saldo']
                else:
                    if df.loc[i, 'kode'] == 'K':
                        df.loc[i, 'saldo'] = df.loc[i - 1, 'saldo'] + df.loc[i, 'mutasi']
                    elif df.loc[i, 'kode'] == 'D':
                        df.loc[i, 'saldo'] = df.loc[i - 1, 'saldo'] - df.loc[i, 'mutasi']
                    else:
                        # Handle cases where trx_code is neither 'K' nor 'D' (optional)
                        df.loc[i, 'saldo'] = df.loc[i-1, 'saldo']'''

            ls_df.append(df)

        except Exception as e:
            print(f"Error processing {pdf_file}: {e}")

else:
    print("No PDF files found in the current directory.")

if pdf_list:
    df_all = pd.concat(ls_df, ignore_index=True)
    df_all = df_all.sort_values(by=['no_rekening', 'tanggal', 'sequence'])
    df_clean = df_all[['no_rekening', 'tanggal', 'keterangan', 'kode', 'mutasi', 'saldo']]
    df_clean

if pdf_list:
    df_clean.to_excel('Mandiri_Excel.xlsx', index=False)
